# CategoryScreen 分页功能使用示例

## 🎯 新增参数说明

CategoryScreen 组件现在支持通过参数传递分页状态，无需使用全局状态管理。

### 新增参数：

```javascript
<CategoryScreen 
  // 原有参数...
  category="document"
  city="北京"
  onBack={() => {}}
  
  // 新增分页参数
  initialPage={5}                    // 初始页面，默认为1
  itemsPerPage={100}                 // 每页数量，默认为50
  onPageChange={(pageInfo) => {      // 页面变化回调
    console.log('页面变化:', pageInfo);
  }}
/>
```

## 📋 参数详情

### `initialPage` (number, 可选)
- **默认值**: `1`
- **说明**: 组件初始化时显示的页面
- **示例**: `initialPage={5}` - 初始显示第5页

### `itemsPerPage` (number, 可选)
- **默认值**: `50`
- **说明**: 每页显示的图片数量
- **可选值**: `20`, `50`, `100`
- **示例**: `itemsPerPage={100}` - 每页显示100张图片

### `onPageChange` (function, 可选)
- **默认值**: `null`
- **说明**: 当页面或每页数量发生变化时的回调函数
- **参数**: `pageInfo` 对象，包含以下属性：
  ```javascript
  {
    currentPage: 3,        // 当前页码
    itemsPerPage: 50,      // 每页数量
    totalPages: 772,       // 总页数
    category: "document",  // 分类
    city: "北京"           // 城市
  }
  ```

## 🚀 使用场景示例

### 场景1: 基本使用（使用默认值）
```javascript
<CategoryScreen 
  category="document"
  city="北京"
  onBack={() => {}}
/>
// 默认显示第1页，每页50张图片
```

### 场景2: 指定初始页面
```javascript
<CategoryScreen 
  category="document"
  city="北京"
  onBack={() => {}}
  initialPage={10}
/>
// 初始显示第10页
```

### 场景3: 自定义每页数量
```javascript
<CategoryScreen 
  category="document"
  city="北京"
  onBack={() => {}}
  itemsPerPage={100}
/>
// 每页显示100张图片
```

### 场景4: 监听页面变化（用于状态持久化）
```javascript
const [pageState, setPageState] = useState({
  currentPage: 1,
  itemsPerPage: 50,
  category: "document"
});

const handlePageChange = (pageInfo) => {
  setPageState({
    currentPage: pageInfo.currentPage,
    itemsPerPage: pageInfo.itemsPerPage,
    category: pageInfo.category
  });
  
  // 保存到本地存储
  localStorage.setItem('categoryPageState', JSON.stringify(pageState));
};

<CategoryScreen 
  category="document"
  city="北京"
  onBack={() => {}}
  initialPage={pageState.currentPage}
  itemsPerPage={pageState.itemsPerPage}
  onPageChange={handlePageChange}
/>
```

### 场景5: 从URL参数恢复页面状态
```javascript
const urlParams = new URLSearchParams(window.location.search);
const pageFromUrl = parseInt(urlParams.get('page')) || 1;
const itemsFromUrl = parseInt(urlParams.get('items')) || 50;

<CategoryScreen 
  category="document"
  city="北京"
  onBack={() => {}}
  initialPage={pageFromUrl}
  itemsPerPage={itemsFromUrl}
  onPageChange={(pageInfo) => {
    // 更新URL参数
    const newUrl = new URL(window.location);
    newUrl.searchParams.set('page', pageInfo.currentPage);
    newUrl.searchParams.set('items', pageInfo.itemsPerPage);
    window.history.replaceState({}, '', newUrl);
  }}
/>
```

## 🔄 状态管理建议

### 方案1: 组件内部状态（简单场景）
```javascript
// 适用于简单的页面跳转，不需要持久化
<CategoryScreen 
  category="document"
  onBack={() => {}}
  initialPage={1}
/>
```

### 方案2: 父组件状态（中等复杂度）
```javascript
const ParentComponent = () => {
  const [pageState, setPageState] = useState({
    currentPage: 1,
    itemsPerPage: 50
  });

  return (
    <CategoryScreen 
      category="document"
      onBack={() => {}}
      initialPage={pageState.currentPage}
      itemsPerPage={pageState.itemsPerPage}
      onPageChange={(pageInfo) => {
        setPageState({
          currentPage: pageInfo.currentPage,
          itemsPerPage: pageInfo.itemsPerPage
        });
      }}
    />
  );
};
```

### 方案3: 全局状态管理（复杂应用）
```javascript
// 使用 Redux/Zustand 等状态管理库
const usePageStore = create((set) => ({
  pageState: {},
  setPageState: (category, pageInfo) => set((state) => ({
    pageState: {
      ...state.pageState,
      [category]: pageInfo
    }
  }))
}));

const CategoryScreenWrapper = ({ category }) => {
  const { pageState, setPageState } = usePageStore();
  const currentPageState = pageState[category] || { currentPage: 1, itemsPerPage: 50 };

  return (
    <CategoryScreen 
      category={category}
      onBack={() => {}}
      initialPage={currentPageState.currentPage}
      itemsPerPage={currentPageState.itemsPerPage}
      onPageChange={(pageInfo) => setPageState(category, pageInfo)}
    />
  );
};
```

## ✅ 优势

1. **灵活性**: 支持外部控制分页状态
2. **可复用**: 同一个组件可以有不同的分页配置
3. **状态持久化**: 通过回调函数可以实现状态保存
4. **URL同步**: 可以轻松实现URL参数同步
5. **向后兼容**: 所有新参数都是可选的，不影响现有代码

## 🎉 总结

通过参数传递分页状态，CategoryScreen 组件变得更加灵活和可控制，同时保持了向后兼容性。你可以根据具体需求选择合适的方案来管理分页状态。
